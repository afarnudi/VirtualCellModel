#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 29 14:40:30 2019

@author: alifarnudi
"""
import numpy as np
#import matplotlib.pyplot as plt

def read_file(filename):
    """
    This function reads a 3D mesh created by Gmsh mesh generator. It will then seperate and returns the Node coordinates, 
    nodes that form triangles, and nodes that form pyromids.
    
    """
    with open(filename) as file:
        count_1=0
        count_2=0
        count_3=-3
        num_of_nodes=0
        num_of_tri=0
        Nodes=[]
        Tris=[]
        Pyr=[]
        print('\nWhat I found in "{}":'.format(filename))
        for line in file:
            count_1 += 1
            if count_1 == 5:
                num_of_nodes=int(line)
                print('\n{} nodes,'.format(num_of_nodes) )
            elif count_2 != num_of_nodes :
                count_2 += 1
                split=line.split()
                Nodes.append( ( float('%.5f' % float(split[1]) ), float('%.5f' % float(split[2]) ), float('%.5f' % float(split[3]) ) ) )
            elif count_3 < -1 and num_of_nodes != 0:
                count_3 += 1
            elif count_3 == -1:
                num_of_tri = int(line)
                count_3 +=1
            elif count_3 >= 0 and count_3 < num_of_tri:
                count_3 +=1
                split=line.split()
                if len(split) == 8:
                    Tris.append( tuple([int(split[5]), int(split[6]), int(split[7])]) )
                elif len(split) == 9:
                    Pyr.append( tuple([int(split[5]), int(split[6]), int(split[7]), int(split[8])]) )
                else:
                    print('{} triangles (elements with 3 nodes),'.format(len(Tris) ) )
                    print('{} pyramids  (elements with 4 nodes).'.format(len(Pyr ) ) )
                    return Nodes, Tris, Pyr
    print('{} triangles (elements with 3 nodes),'.format(len(Tris) ) )
    print('{} pyramids  (elements with 4 nodes).'.format(len(Pyr ) ) )
    return Nodes, Tris, Pyr

def find_radii(Node_list):
    """
    This function makes a list of all the node distances from the origin (0, 0, 0), sorts the list, 
    and returns the Min (first element) and Max (last element) of the list. 
    """
    r=[]
    for i in Node_list:
        add=True
        r_temp=np.sqrt(np.sum(np.square(np.array(i))))
        for j in r:
            if r_temp > 0.99*j and r_temp < 1.01*j:
                add=False
        if(add):
            r.append(r_temp)
    r=sorted(r)
    return r[0],r[-1]

def find_nodes(node_list, radius):
    """
    This function uses the coordinates from the 'node_list' and calculates their distance from the origin (0, 0, 0).
    After which, it will make a list of all the nodes that have a distance within 1% of the input 'radius'.s
    """
    nodes=[]
    for i in node_list:
        r_temp=np.sqrt(np.sum(np.square(np.array(i))))
        if r_temp > 0.99*radius and r_temp < 1.01*radius:
            nodes.append(i)
    return nodes

def find_act_nodes(all_nodes, first_nodes, second_nodes):
    """
    This function returns all the nodes in 'all_nodes' that are not in 'first_nodes' and 'second_nodes'.
    """
    master_set = set(all_nodes)
    set_1 = set(first_nodes)
    set_2 = set(second_nodes)
    act_set = master_set.difference(set_1)
    act_set = act_set.difference(set_2)
    return list(act_set)

def write(nodes, tris, file_name):
    """
    In this function we write a mesh file that resembles the Gmsh V2.0 format style.
    This format generaly starts with the number of elements, followed by the element parameters.
    Example: number of nodes in the mesh, followed by the node coordinates.
    """
    with open(file_name, 'w') as f:
        f.write("$MeshFormat\n2.2 0 8\n$EndMeshFormat\n$Nodes\n")
        f.write(str(len(nodes))+'\n')
        count=0
        for node in nodes:
            count += 1
            f.write('{} {} {} {}\n'.format(count ,node[0],node[1],node[2]))
        f.write("$EndNodes\n$Elements\n")
        f.write(str(len(tris))+'\n')
        count =0
        for tri in tris:
            count +=1
            if len(tri) == 3:
                f.write('{} 0 0 0 0 {} {} {}\n'.format(count,tri[0],tri[1],tri[2]) )
            elif len(tri) == 4:
                f.write('{} 0 0 0 0 {} {} {} {}\n'.format(count,tri[0],tri[1],tri[2], tri[3]) )
        f.write("$EndElements")
        
def find_tris(node_all, tri_all, nodes):
    tri=[]
    for i in tri_all:
        if node_all [i[0]-1] in nodes:
            tri.append( [nodes.index(node_all[i[0]-1])+1, nodes.index(node_all[i[1]-1])+1, nodes.index(node_all[i[2]-1])+1   ]  )
    return tri

def main():    
    
    message ="""
    Hi!\nThis programme will take a spherical 3D mesh generated by Gmsh with the version 2 
    formatting style and look for membranes (triangulated surfaces). It will then seperate 
    the foud membrane(s)from the bulk mesh (actin).
                          
    After analysis is finished the programme saves the membrane(s) and actin into seperate files 
    ready for importing into The Vertual Cell Model software package.\n\n
                              
    Please enter the 3D mesh file name:
    """

    file_name_act = input(message)

    Nodes_all, Tris_all, pyr_act = read_file(file_name_act)

    radius_in, radius_out=find_radii(Nodes_all)

    nodes_r_in  = find_nodes(Nodes_all, radius_in)
    nodes_r_out = find_nodes(Nodes_all, radius_out)
#    act_nodes   = find_act_nodes(Nodes_all, nodes_r_in, nodes_r_out)

    tri_r_in    = find_tris(Nodes_all, Tris_all, nodes_r_in)
    tri_r_out   = find_tris(Nodes_all, Tris_all, nodes_r_out)    
    
    print('\n----------------------------\n')
    print('The actin has {} nodes and {} pyramids,'.format(len(Nodes_all),  len(pyr_act) ) )
    if len(tri_r_in) != 0:
        
        print('\nI found two membranes. The radii are r_1 = {} and r_2 = {}'.format(round(radius_in,5), round(radius_out,5) ) ) 
        print('Membrane 1 has {} nodes and {} triangles and a radius of {}'.format(len(nodes_r_in),  len(tri_r_in), round(radius_in,5) ) )
        print('Membrane 2 has {} nodes and {} triangles and a radius of {}'.format(len(nodes_r_out),  len(tri_r_out), round(radius_out,5) ) )
        filename = input("What should I call the membrane mesh with radius {}?\n".format(round(radius_in,5) ) )
        write (nodes_r_in, tri_r_in, filename)
    else :
        
        print('\nI only found one membrane.' )
        print('It has {} nodes and {} triangles and a radius of {}'.format(len(nodes_r_out),  len(tri_r_out), round(radius_out,5) ) )
    
    filename = input("What should I call the membrane with radius {}?\n".format(round(radius_out,5) ))
    write (nodes_r_out, tri_r_out, filename)
    filename = input("What should I call the actin mesh?\n")
    write (Nodes_all, pyr_act, filename)






if __name__=='__main__':
    main()











